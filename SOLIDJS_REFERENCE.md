SolidJS: A Technical Reference for AI AgentsSection 1: Foundational Principles and ArchitectureThis section details the core architectural decisions and philosophical underpinnings of SolidJS. An understanding of these principles is essential for generating idiomatic, performant, and correct code, as they dictate the behavior of the entire framework.1.1 The Core Philosophy: Performance, Pragmatism, and ProductivitySolidJS is a JavaScript framework engineered with three primary goals: performance, pragmatism, and productivity.1 Its design prioritizes exceptional speed and low memory utilization, consistently ranking at the top of performance benchmarks by minimizing framework overhead.2 This focus on performance is not an afterthought but the central driver of its architecture.The framework is also pragmatic, offering developers flexibility rather than enforcing rigid methodologies.1 This is evident in its composable reactive primitives and the freedom it provides in structuring application logic. Finally, SolidJS aims for high productivity with a clear and predictable API. For developers with experience in modern JavaScript frameworks, particularly React's functional components and Hooks, SolidJS presents a familiar development model based on unidirectional data flow and read/write segregation, which simplifies the learning curve.21.2 The Compiler-First ApproachSolidJS is fundamentally a compiled framework, a characteristic that is central to its performance model.3 Unlike libraries that interpret JSX at runtime to build a virtual representation of the DOM, the SolidJS compiler processes JSX templates during the build step. This compilation transforms declarative JSX into highly optimized, imperative JavaScript code that directly creates and manipulates real DOM nodes.3This pre-compilation strategy shifts a significant amount of work from runtime to compile-time. The output consists of an initial HTML template string, which can be efficiently cloned for new component instances, and a series of precise, targeted functions for updating specific parts of that DOM when reactive data changes.5 This results in smaller application bundle sizes and significantly faster execution, as the browser is given direct instructions rather than having to compute differences between virtual trees.31.3 The Absence of a Virtual DOMA direct consequence of the compiler-first approach is the complete absence of a Virtual DOM (VDOM).3 Frameworks like React and Vue use a VDOM as an abstraction layer to manage state changes; they create a virtual copy of the DOM, update it based on state changes, and then run a "diffing" algorithm to determine the minimal set of changes to apply to the actual DOM. SolidJS circumvents this entire process, which is a known source of performance overhead.2Instead of diffing, updates are surgical. The compiler generates code that establishes a direct link between reactive state and the specific DOM nodes that depend on it. When state changes, only the code responsible for updating those exact nodes is executed. This model of direct, fine-grained updates is what allows SolidJS to achieve its high performance ratings.21.4 "Vanishing Components": The Component-as-Constructor ModelThe most critical mental model for an AI agent to adopt when working with SolidJS is that of "vanishing components".6 A SolidJS component is a function that is executed only once during its lifecycle.7 It is not a "render" function that re-runs on every state change. Instead, it behaves like a constructor or a setup function.7During this single execution, the component function's purpose is twofold:To create the initial DOM structure as defined by its JSX.To establish the reactive graph by creating signals, effects, and other reactive primitives.After this initial setup, the component function effectively "vanishes"; it is never called again. All subsequent UI updates are handled independently by the fine-grained reactive system that was established during the setup phase.6 This architectural decision is the logical conclusion of the no-VDOM, compiler-first approach. If there is no VDOM to re-render, there is no need to re-execute the component function to generate a new virtual tree. This single principle is the root cause of many of SolidJS's specific rules and patterns, such as the prohibition against destructuring props and the necessity of using dedicated control-flow components, which are detailed in subsequent sections.Section 2: The Fine-Grained Reactivity SystemThe mechanism that powers all dynamic updates in SolidJS is its fine-grained reactivity system. This system is responsible for tracking dependencies between state and UI and executing precise updates when data changes.2.1 The Observer Pattern: Signals, Subscribers, and the Global StackAt its core, Solid's reactivity is a sophisticated implementation of the Observer design pattern.9 The system is composed of two primary actors:Signals (Observables): These are the data containers. A signal holds a value and maintains a list of subscribers (functions) that depend on that value.9Subscribers (Observers): These are computations that need to re-execute when a signal they depend on changes. In SolidJS, the primary subscribers are createEffect and createMemo computations.9When a signal's value is updated via its setter function, it iterates through its list of subscribers and notifies them, triggering their re-execution.9 This simple yet powerful model forms the foundation of all reactivity in the framework.2.2 Automatic Dependency TrackingSolidJS features automatic dependency tracking, meaning developers do not need to manually declare dependency arrays as in some other frameworks.9 The system automatically discovers which signals a subscriber depends on. This is achieved through an elegant runtime mechanism involving a global execution stack.9The process is as follows:Before a subscriber (e.g., an effect) begins to execute its function, it pushes itself onto this global stack.Inside the function, whenever a signal's getter function (e.g., count()) is called, the getter checks the global stack.If it finds a subscriber on the stack, it adds that subscriber to its own internal list of subscriptions.After the subscriber's function finishes executing, it pops itself off the stack.This dynamic system allows dependencies to change over time based on conditional logic within a subscriber, offering greater flexibility than static analysis.9 It is crucial to note that this tracking mechanism is synchronous. Any code that runs asynchronously within a subscriber, such as in a setTimeout callback or after an await statement, will execute outside of the tracking scope and will not register dependencies.9 The context of the call—the presence of a tracking scope—is what activates reactivity. Therefore, to achieve reactive behavior, signal accessors must be called exclusively within these scopes (e.g., JSX, effects, memos).2.3 The Three Pillars of Reactivity: Signals, Memos, and EffectsThe reactive system is built upon three primary primitives 9:Signals (createSignal): The most fundamental primitive. A signal tracks a single value that can change over time and notifies its dependents upon update. It is the core unit of state.9Effects (createEffect): The primary mechanism for creating side effects. An effect tracks its dependencies and re-runs its function whenever they change. This is used for interacting with systems outside of Solid's reactive world, such as direct DOM manipulation, logging, or network requests.9Memos (createMemo): A specialized primitive for creating cached, derived reactive values. A memo tracks its own dependencies and re-executes only when they change. It, in turn, acts as a signal itself, notifying its own dependents only when its output value changes. This is used for optimizing expensive computations.92.4 Execution Model: Synchronous by Default, Batched UpdatesBy default, Solid's reactivity is synchronous and predictable. When a signal is updated, its dependent subscribers are re-run immediately.10 However, to prevent redundant work when multiple signals are updated in quick succession (e.g., within a single event handler), SolidJS automatically batches these updates. Effects are not run immediately after each individual setter call; instead, they are scheduled to run once after the current block of code has finished executing. This ensures that an effect depending on multiple changing signals will only run once with the latest values. The batch utility is available for manual control over this process.10Section 3: API Reference: Core Reactive PrimitivesThis section provides a detailed, machine-referenceable breakdown of the three fundamental reactive primitives in SolidJS.3.1 createSignalPurpose: To create the most basic reactive state atom, which holds a single value and can be observed for changes.10Syntax:JavaScriptimport { createSignal } from 'solid-js';
const [get, set] = createSignal(initialValue, options?);
Return Value: A two-element array (tuple) containing an accessor and a setter: ``.12Accessor (get): A function that returns the signal's current value. Critically, calling this function within a tracking scope (like an effect or JSX) registers that scope as a dependency.12Setter (set): A function to update the signal's value. It can be called with the new value directly (set(newValue)) or with an updater function that receives the previous value (set(prev => prev + 1)).12Critical Rule: The value must be read by invoking the accessor as a function (e.g., count()). This is a deliberate design choice because primitive values in JavaScript (like numbers or strings) cannot be proxied to detect access. Using functions provides a universal API for reactivity.4 This tuple pattern is also a direct manifestation of the framework's "read/write segregation" philosophy, making data flow explicit and preventing state from being easily mutated by consumers.4Options:equals: A boolean or a custom comparison function (prev, next) => boolean. By default, updates are suppressed if the new value is strictly equal (===) to the old one. Setting equals: false forces an update even if the value is the same, which is useful for triggering effects with mutable objects that have been modified in place.11name: A string used for debugging purposes, which will appear in Solid's devtools.123.2 createEffectPurpose: To create a computation that runs side effects (e.g., DOM manipulation, logging, data fetching) in response to changes in its reactive dependencies.9Syntax:JavaScriptimport { createEffect } from 'solid-js';
createEffect((prevValue) => {
  // Side effect code using reactive values like count()
  const currentValue = count();
  console.log(`The count is now ${currentValue}`);
  return currentValue; // This returned value becomes prevValue in the next run
}, initialValue?);
Execution Timing: An effect's first run is scheduled to occur after the initial component render is complete and the corresponding DOM elements have been mounted. It does not run immediately upon creation.13 For effects that must run synchronously with the render phase (e.g., to read DOM layout before the browser paints), createRenderEffect should be used instead.13Cleanup: To prevent memory leaks, side effects should be cleaned up. This is done by calling onCleanup inside the effect. The provided cleanup function will be executed just before the effect runs again, or when its containing scope is disposed of entirely.13JavaScriptcreateEffect(() => {
  const timer = setInterval(() => console.log('tick'), 1000);
  onCleanup(() => clearInterval(timer));
});
Purity Guideline: Effects are designed for interactions with the "outside world." It is best to avoid setting other signals within an effect. Doing so can create complex, hard-to-debug reactive flows or even infinite loops. For deriving new reactive state from existing state, createMemo is the correct tool.133.3 createMemoPurpose: To create a derived, readonly reactive value that is efficiently cached. The memo's calculation function only re-executes when its specific dependencies change, and it only notifies its own dependents if its output value has changed.9Syntax:JavaScriptimport { createMemo } from 'solid-js';
const fullName = createMemo(() => `${firstName()} ${lastName()}`);
Return Value: An accessor function, identical in usage to a signal's getter. Reading it via fullName() returns the cached value and registers a dependency.15Use Cases:Performance Optimization: To cache the result of an expensive computation that depends on reactive values, preventing it from being re-calculated on every read.15Reactivity Shielding: A memo acts as a buffer. If its dependencies change, but the resulting output value remains the same (e.g., count() > 10 remains true even as count goes from 11 to 12), any effects that depend on the memo will not re-run, thus preventing unnecessary downstream updates.15Purity Rule: Memo functions must be pure. They should not have any side effects, such as modifying other signals or the DOM. Violating this rule can lead to unpredictable execution order and infinite loops, as a side effect could trigger a change in the memo's own dependencies.14The following table provides a clear decision-making framework for choosing between createMemo and createEffect. createMemo is for creating new reactive information within the system, while createEffect is for getting information out of the system and into the "real world" (DOM, console, network).FeaturecreateMemocreateEffectPrimary GoalDeriving and caching reactive valuesExecuting side effectsReturn ValueAccessor function (readonly signal)voidCaches ResultsYesNoPurityMust be pure (no side effects)Designed for side effectsUse CaseTransforming data, computing aggregatesDOM manipulation, logging, network requestsSection 4: API Reference: Advanced State and Data FetchingFor more complex application requirements, SolidJS provides higher-level primitives for managing nested data structures and asynchronous operations. These primitives are designed to solve common architectural challenges efficiently.4.1 createStorePurpose: To manage complex, nested state objects and arrays. While a createSignal treats an entire object as a single atomic value, createStore provides fine-grained reactivity, tracking changes to individual properties deep within the data structure.17Syntax:JavaScriptimport { createStore } from 'solid-js/store';
const = createStore({
user: { firstName: 'John', lastName: 'Doe' },
posts:
});
Accessing Values: Store values are accessed directly via standard property access (e.g., store.user.firstName). No function call is required. This is possible because createStore wraps the state object in a Proxy, which intercepts property access and automatically registers dependencies within any active tracking scope.8Modifying Values: Updates are performed using the setStore function, which offers a flexible "path syntax" for precise, targeted modifications. This avoids the need to manually create deep copies of the state.17JavaScript// Update a nested property
setStore('user', 'firstName', 'Jane');

// Add an item to an array
setStore('posts', posts => [...posts, { id: 1, title: 'New Post' }]);

// Update an item in an array by index
setStore('posts', 0, 'title', 'Updated Title');
Store Utilities: To simplify complex updates, solid-js/store provides several helper functions 11:produce: An Immer-inspired utility that allows you to write seemingly mutable logic within a callback, which is then translated into a safe, immutable update.18reconcile: Diffs a new data object against the current store state and applies only the necessary changes. This is extremely useful for updating state with data from an API without losing local UI state or triggering unnecessary updates.11unwrap: Returns the raw, non-proxied JavaScript object from the store, useful for when you need to pass the data to non-Solid libraries or serialize it.114.2 createResourcePurpose: A specialized primitive designed to streamline the management of asynchronous data fetching. It encapsulates the common pattern of handling loading, error, and ready states for data that is fetched from an external source.19Syntax:JavaScriptimport { createResource } from 'solid-js';
// Simple fetcher
const [user] = createResource(fetchUser);

// Fetcher that depends on a signal (re-fetches when userId changes)
const [userId, setUserId] = createSignal(1);
const [user] = createResource(userId, fetchUser);
Return Value: The createResource function returns a tuple [data, { mutate, refetch }]. The data object is a special reactive accessor with additional properties for tracking the fetch status 19:data(): Accesses the fetched data. If the data is not yet available, it will trigger the nearest <Suspense> boundary.data.loading: A reactive boolean accessor that is true while the fetcher function is in flight.data.error: Contains the error object if the promise was rejected.data.latest: A reactive accessor that returns the most recently resolved value. Unlike data(), it does not trigger <Suspense> and can be used to show stale data while new data is loading.Fetcher Function: The async function passed to createResource receives the value of the source signal (if provided) as its first argument, and an info object as its second: async (sourceValue, { value, refetching }) => {... }. The value property contains the previously fetched value, which can be useful for pagination or caching logic.19Actions:mutate(newValue): Allows for optimistic updates by directly setting the resource's data value without re-running the fetcher.19refetch(): Manually triggers a re-execution of the fetcher function with its last known source value.19These advanced primitives map directly to common application architecture layers. createSignal is suited for simple, local component state. createStore is ideal for managing complex client-side state models. createResource provides the foundation for the data service layer that communicates with external APIs. Selecting the appropriate primitive for the architectural role of the data is key to building robust SolidJS applications.Section 5: Rendering and Control FlowThis section details how SolidJS connects its reactive system to the DOM through JSX and a set of specialized control-flow components. Understanding these mechanisms is crucial for building dynamic and efficient user interfaces.5.1 JSX and Component FunctionsComponents in SolidJS are defined as functions with PascalCase names that return JSX.5 As established, this function runs only once. The JSX it returns is not a virtual representation but a template for creating real DOM elements. The Solid compiler transforms this JSX into two parts:A highly efficient DOM element template that can be cloned for each instance of the component.A series of imperative JavaScript statements that surgically update specific parts of that cloned template when reactive dependencies change.55.2 Handling Props: The Reactivity MinefieldProps are the primary way to pass data from a parent to a child component. However, due to Solid's unique reactivity model, they must be handled with care to avoid breaking reactivity.21Props as Reactive Getters: The props object received by a component is not a plain JavaScript object. It is a Proxy where each property is a getter. Accessing a property like props.name within a tracking scope establishes a subscription to that property's underlying reactive source.21CRITICAL RULE: DO NOT DESTRUCTURE PROPS: A common mistake is to destructure the props object at the top level of a component function: const { name } = props;. This action calls the name getter once, during the component's single execution, outside of any tracking scope. The value is assigned to a static, non-reactive variable name. When the parent passes a new value for the name prop, this variable will not update, and the reactivity is lost.22 The correct approach is to always access props directly via props.name within JSX or effects.Safe Prop Handling Utilities: Solid provides helpers to work with props objects without breaking reactivity:mergeProps: Safely merges multiple props objects. This is the recommended way to apply default props, as it preserves the reactivity of all sources.21splitProps: Provides a safe, reactive alternative to destructuring. It allows you to split a props object into multiple smaller, reactive props objects based on key names. This is useful for separating props intended for the component itself from those that should be passed down to a child element.225.3 Control Flow ComponentsThe "vanishing component" model necessitates the use of specialized components for conditional and list rendering. Standard JavaScript constructs like if/else statements or array.map() used directly in the JSX body would only execute once and would not react to state changes.4 Control flow components solve this by creating internal reactive scopes that re-evaluate their children when their dependencies change.<Show>: For conditional rendering. It takes a when prop and renders its children only when the condition is truthy. An optional fallback prop can be provided to render content when the condition is falsy.26JavaScript<Show when={user.loggedIn()} fallback={<LoginButton />}>
<UserProfile />
</Show>
<Switch> and <Match>: For handling multiple, mutually exclusive conditions, analogous to a JavaScript switch statement. The <Switch> component evaluates its child <Match> components in order and renders the first one whose when condition is met.28JavaScript<Switch fallback={<p>Status Unknown</p>}>
<Match when={status() === 'loading'}><Spinner /></Match>
<Match when={status() === 'error'}><ErrorMessage /></Match>
<Match when={status() === 'success'}><DataDisplay /></Match>
</Switch>
<For> and <Index>: For efficiently rendering lists. Using array.map() directly is inefficient as it would recreate all DOM nodes for the entire list on any change. <For> and <Index> perform optimized, granular updates. The choice between them is critical for performance.4The following table outlines the key differences and appropriate use cases for <For> and <Index>. This distinction is vital, as using the wrong component can lead to performance issues or unexpected behavior, such as state loss in child components upon re-sorting.Feature<For><Index>Keying StrategyKeyed by data item referenceKeyed by array indexRender Callback Args(item, indexSignal)(itemSignal, index)Behavior on ReorderMoves existing DOM nodesUpdates data within static DOM nodesBest Use CaseLists of objects with stable IDsLists of primitive values (strings, numbers)Section 6: API Reference: Component Lifecycle and ContextSolidJS provides APIs for managing side effects tied to a component's presence in the DOM and for sharing state across the component tree without prop drilling.6.1 onMount and onCleanupUnlike in VDOM libraries where lifecycles are tied to the component instance, in Solid, lifecycle functions are tied to the reactive scope in which they are defined.30onMount(fn): Registers a function to be executed once, after the initial render is complete and the component's elements have been mounted to the DOM. It runs in a non-tracking scope, making it equivalent to a createEffect with no dependencies.31 This is the ideal place for one-time setup logic, such as initializing a third-party charting library on a <canvas> element or focusing an input field.3onCleanup(fn): Registers a cleanup function to be executed when the current reactive scope is disposed of. This occurs when a component is unmounted from the DOM or when an effect it is nested within re-runs.30 It is essential for preventing memory leaks by removing event listeners, clearing timers, or disconnecting observers that were set up in onMount or createEffect.306.2 createContext and useContextFor cases where state needs to be shared across deeply nested components, Solid provides a dependency injection mechanism called Context to avoid "prop drilling".33createContext(defaultValue?): This function creates a context object. This object contains a Provider component that will be used to supply the context value. It is a best practice to define each context in its own module to ensure it works correctly with Hot Module Replacement (HMR).35<MyContext.Provider value={...}>: This component is used to wrap a part of the component tree. The value prop it receives is made available to all descendant components that request this context.33 The value can be any data, including signals or stores, which should be passed directly to preserve reactivity.35useContext(MyContext): This function is called within a descendant component to access the value provided by the nearest ancestor Provider. If no Provider is found in the hierarchy, it will return the defaultValue provided to createContext, or undefined if none was given.33Best Practice: While Context is powerful, it can add complexity. For many global state scenarios, simply defining and exporting a signal or a store from a module can be a simpler and equally effective solution for sharing state.336.3 The children HelperPurpose: To safely access and memoize a component's props.children. Accessing props.children directly can be problematic if it needs to be referenced multiple times, as this can lead to the children being re-created or re-evaluated unnecessarily. The children helper resolves the children once and returns a memoized accessor.22Syntax:JavaScriptimport { children } from 'solid-js';
function MyLayout(props) {
const resolvedChildren = children(() => props.children);
return (
<>

<header>Header</header>
<main>{resolvedChildren()}</main>
<footer>Footer</footer>
</>
);
}
Section 7: Critical Best Practices and Common PitfallsThis section consolidates the most critical rules and common anti-patterns. Adhering to these guidelines is paramount for an AI agent to generate correct and performant SolidJS code. The majority of these pitfalls stem from applying mental models from VDOM-based frameworks to Solid's fundamentally different architecture.87.1 Reactivity Rules: Where and When to Access Reactive ValuesRule: To create a reactive subscription, a reactive value (from a signal, prop, or store) must be accessed from within a tracking scope. The primary tracking scopes are JSX expressions, createEffect, and createMemo.9Pitfall: Accessing a reactive value at the top level of a component function body does not create a subscription. It is a one-time read of the value during the component's initial setup.9JavaScriptfunction MyComponent(props) {
// ❌ PITFALL: This reads props.name once and will not update.
const name = props.name;

createEffect(() => {
// ✅ CORRECT: Accessing props.name here creates a subscription.
console.log(props.name);
});

// ✅ CORRECT: Accessing props.name here creates a subscription for the UI.
return <div>{props.name}</div>;
}
7.2 Asynchronous Code in Effects: The Tracking TrapRule: Solid's automatic dependency tracking is a synchronous process.9Pitfall: Any signal read within an asynchronous callback (e.g., inside setTimeout, Promise.then, or after an await statement) will occur outside the original tracking scope. The effect will not re-run when that signal changes.9Solution: For reactivity that depends on the result of an async operation, nest a new createEffect inside the async callback. This creates a new tracking scope that can properly subscribe to subsequent dependencies.23JavaScriptcreateEffect(async () => {
const user = await fetchUser(userId()); // `userId` is tracked.

// ❌ PITFALL: `someOtherSignal` is read after `await`, so it is NOT tracked.
console.log(user.name, someOtherSignal());

// ✅ SOLUTION: Create a new effect to track post-async dependencies.
createEffect(() => {
console.log(user.name, someOtherSignal()); // `someOtherSignal` is now tracked.
});
});
7.3 Event Handling: onInput vs. onChangeRule: SolidJS adheres to the standard browser event model for form inputs.4Pitfall: Developers coming from React often expect onChange to fire on every keystroke. In native DOM behavior (and thus in Solid), onChange typically fires only when the input element loses focus (on blur).4Solution: To handle input changes in real-time as the user types, always use the onInput event handler.47.4 TypeScript Configuration and Common Type IssuesConfiguration: A tsconfig.json file for a SolidJS project must include the following compiler options: "jsx": "preserve" and "jsxImportSource": "solid-js".38Pitfall (Function Setters): When storing a function in a signal, the setter can be ambiguous. setValue(myFunction) will execute myFunction and store its return value. To store the function itself, use the functional update form: setValue(() => myFunction).12Pitfall (Context Types): useContext(MyContext) can return undefined if a Provider is not found in the component tree. This can lead to runtime errors and requires type guards in TypeScript. The recommended solution is to either provide a default value to createContext or create a custom hook that throws an error if the context is not found, which also serves to narrow the type for TypeScript.33Section 8: Ecosystem and ToolingWhile SolidJS provides a powerful core, a rich ecosystem of libraries and tools supports the development of full-scale applications.8.1 Official ToolingThe core SolidJS team maintains several key packages that form the foundation of most projects 39:SolidStart: The official meta-framework for SolidJS. It provides a comprehensive solution for building applications with features like server-side rendering (SSR), file-system-based routing, API routes, and optimized builds.@solidjs/router: A flexible routing library for client-side navigation in single-page applications.eslint-plugin-solid: An ESLint plugin that provides rules to enforce best practices and catch common errors, such as destructuring props or misusing reactive primitives.8.2 Key Community LibrariesThe SolidJS community has developed a wide range of libraries to address common needs 39:UI Component Libraries: Projects like solid-bootstrap and flowbite-solidjs provide pre-built, accessible UI components that integrate seamlessly with Solid's reactivity.39Primitives and Utilities: solid-primitives is a high-quality, essential library that offers a vast collection of reusable reactive building blocks for everything from event listeners and timers to complex state management patterns. It is a primary resource for composing complex reactive logic.40Data Fetching and Caching: For more advanced data fetching patterns beyond what createResource offers, solid-query (a port of the popular TanStack Query) provides features like caching, request deduplication, and background refetching.Babel Plugins: For developers who prefer destructuring props, babel-plugin-solid-undestructure can be used to transform destructuring assignments at compile-time to preserve reactivity.4The ecosystem is robust for core application requirements. However, for highly specialized or niche use cases, the number of available libraries may be smaller than in more established ecosystems.40 In such cases, the solution often involves leveraging Solid's powerful primitives to integrate directly with vanilla JavaScript libraries.
